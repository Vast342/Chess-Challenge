/* IDEA 1 
        // The array of lists of possible moves, in which each list is a different depth of the search depending on where it is 
        List<Move>[] moves = new List<Move>[2];
        // initializes the first list of possible moves and captures, with a search depth of 1
        moves[0] = board.GetLegalMoves().ToList();
        moves[1]= board.GetLegalMoves(true).ToList();
        PieceList[] pieces = board.GetAllPieceLists();
        int[] index = new int[5];
        for(int i = 0; i < moves[0].Count; i++) {
            board.MakeMove(moves[0][i]);
            if(board.IsInCheckmate()) {
                return moves[0][i];
            }
            board.UndoMove(moves[0][i]);
            if(board.IsWhiteToMove) {
                for(int j = 0; j < 6; j++) {
                    index[3] += pieces[j].Count;
                }
                for(int j = 6; j < 12; j++) {
                    index[4] += pieces[j].Count;
                }
                index[2] += index[3] / index[4] * 8;
            } else {
                for(int j = 0; j < 6; j++) {
                    index[4] += pieces[j].Count;
                }
                for(int j = 6; j < 12; j++) {
                    index[3] += pieces[j].Count;
                }
                index[2] += index[4] / index[3] * 8;
            }
            index[2] += (moves[1].Count * 2) + moves[0].Count;
            if(index[2] > index[1]) {
                index[0] = i;
                index[1] = index[2];
            }
        }
        if(moves[0][index[0]] != Move.NullMove) {
            return moves[0][index[0]];
        } else {
            return moves[0][0];
        }
        */


        // IDEA 2

        //Board data = Board.CreateBoardFromFEN("QQQQQQQQ/QQQQQQQQ/QQQQQQQQ/QQQQQQQQ/QQQQQQQQ/QQQQQQQQ/QQQQQQQQ/QQQQQQQQ");
        //Console.WriteLine(board.ZobristKey);
        //Console.WriteLine(board.GetFenString());
        //return board.GetLegalMoves()[0];


        /*
        // Idea 3
        // randomizer if it can't decide on a move
        var rng = new Random();
        // lists of possible moves
        Move[] moves = board.GetLegalMoves();
        Move[] captures = board.GetLegalMoves(true);
        // these are used for the deeper search
        Move[] moreMoves;
        Move[] moreMoreMoves;
        //Move[] moreMoreMoreMoves;
        // a few bools for if a piece is defended or not and if a particular checkmate idea is preventable or not.
        bool attacked;
        bool preventable;
        // an index to be used for randomizer later
        int index = 0;
        // depth 1 search
        foreach(Move move in moves) {
            // it's funny
            if(move.IsEnPassant)return move;
            // detection for if a move is attacked
            attacked = board.SquareIsAttackedByOpponent(move.TargetSquare);
            // make the move
            board.MakeMove(move);
            // if mate in 1, DO IT
            if(board.IsInCheckmate()) {
                return move;
            }
            // depth 2 search
            moreMoves = board.GetLegalMoves();
            foreach(Move move1 in moreMoves) {
                // make the move
                board.MakeMove(move1);
                // if the opponent has mate in 1
                if(board.IsInCheckmate()) {
                    // PANIC
                    // goes back to searching the player's move
                    moreMoreMoves = board.GetLegalMoves();
                    board.UndoMove(move1);
                    board.UndoMove(move);
                    // try all of them until its not mate anymore
                    foreach(Move move2 in moves) {
                        board.MakeMove(move2);
                        board.MakeMove(move1);
                        if(!board.IsInCheckmate()) {
                            return move2;
                        }
                        board.UndoMove(move1);
                        board.UndoMove(move2);
                    }
                    // catch up
                    board.MakeMove(move);
                    board.MakeMove(move1);
                }
                // depth 3 search
                moreMoreMoves = board.GetLegalMoves();
                Console.WriteLine(moreMoreMoves.Length);
                foreach(Move move2 in moreMoreMoves) {
                    Console.WriteLine(move2.TargetSquare);
                    // makes the move
                    board.MakeMove(move2);
                    // if mate in 2
                    if(board.IsInCheckmate()) {
                        // check if the mate is preventable
                        board.UndoMove(move2);
                        board.UndoMove(move1);
                        preventable = false;
                        foreach(Move move3 in moreMoves) {
                            board.MakeMove(move3);
                            board.MakeMove(move2);
                            if(!board.IsInCheckmate()) {
                                preventable = true;
                            }
                            board.UndoMove(move2);
                            board.UndoMove(move3);
                        }
                        // if not then do the checkmate
                        if(!preventable) {
                            return move;
                        }
                        board.MakeMove(move1);
                        board.MakeMove(move2);
                    }
                    // undo the moves
                    board.UndoMove(move2);
                }
                board.UndoMove(move1);
            }
            // if not attacked check then go for it
            if(board.IsInCheck() && !attacked) {                
                return move;
            }
            board.UndoMove(move);     
        }
        // random capture (old code was skipping a buncha stuff)
        if(captures.Length > 0) {
            index = rng.Next(0, captures.Length-1);
            return captures[index];
        }
        // random move if its not under attack unless you are in check
        if(board.IsInCheck()) {
            return moves[0];
        } else {
        for(int i = 0; i < 1; i++) {
            index = rng.Next(0, moves.Length-1);
            if(board.SquareIsAttackedByOpponent(moves[index].TargetSquare)) {
                i--;
            }
        }
        return moves[index];
        }

        */
        